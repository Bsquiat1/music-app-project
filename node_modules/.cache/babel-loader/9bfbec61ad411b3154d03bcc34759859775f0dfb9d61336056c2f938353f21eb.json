{"ast":null,"code":"var common = exports,\n  url = require('url'),\n  extend = require('util')._extend,\n  required = require('requires-port');\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\n  isSSL = /^https|wss/;\n\n/**\n * Simple Regex for testing if protocol is https\n */\ncommon.isSSL = isSSL;\n/**\n * Copies the right headers from `options` and `req` to\n * `outgoing` which is then used to fire the proxied\n * request.\n *\n * Examples:\n *\n *    common.setupOutgoing(outgoing, options, req)\n *    // => { host: ..., hostname: ...}\n *\n * @param {Object} Outgoing Base object to be filled with required properties\n * @param {Object} Options Config object passed to the proxy\n * @param {ClientRequest} Req Request Object\n * @param {String} Forward String to select forward or target\n * \n * @return {Object} Outgoing Object with all required properties set\n *\n * @api private\n */\n\ncommon.setupOutgoing = function (outgoing, options, req, forward) {\n  outgoing.port = options[forward || 'target'].port || (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\n  ['host', 'hostname', 'socketPath', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(function (e) {\n    outgoing[e] = options[forward || 'target'][e];\n  });\n  outgoing.method = req.method;\n  outgoing.headers = extend({}, req.headers);\n  if (options.headers) {\n    extend(outgoing.headers, options.headers);\n  }\n  if (options.auth) {\n    outgoing.auth = options.auth;\n  }\n  if (isSSL.test(options[forward || 'target'].protocol)) {\n    outgoing.rejectUnauthorized = typeof options.secure === \"undefined\" ? true : options.secure;\n  }\n  outgoing.agent = options.agent || false;\n  outgoing.localAddress = options.localAddress;\n\n  //\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\n  // as node core doesn't handle this COMPLETELY properly yet.\n  //\n  if (!outgoing.agent) {\n    outgoing.headers = outgoing.headers || {};\n    if (typeof outgoing.headers.connection !== 'string' || !upgradeHeader.test(outgoing.headers.connection)) {\n      outgoing.headers.connection = 'close';\n    }\n  }\n\n  // the final path is target path + relative path requested by user:\n  var target = options[forward || 'target'];\n  var targetPath = target && options.prependPath !== false ? target.path || '' : '';\n\n  //\n  // Remark: Can we somehow not use url.parse as a perf optimization?\n  //\n  var outgoingPath = !options.toProxy ? url.parse(req.url).path || '/' : req.url;\n\n  //\n  // Remark: ignorePath will just straight up ignore whatever the request's\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\n  // you are doing and are using conflicting options.\n  //\n  outgoingPath = !options.ignorePath ? outgoingPath : '/';\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\n  if (options.changeOrigin) {\n    outgoing.headers.host = required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host) ? outgoing.host + ':' + outgoing.port : outgoing.host;\n  }\n  return outgoing;\n};\n\n/**\n * Set the proper configuration for sockets,\n * set no delay and set keep alive, also set\n * the timeout to 0.\n *\n * Examples:\n *\n *    common.setupSocket(socket)\n *    // => Socket\n *\n * @param {Socket} Socket instance to setup\n * \n * @return {Socket} Return the configured socket.\n *\n * @api private\n */\n\ncommon.setupSocket = function (socket) {\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  socket.setKeepAlive(true, 0);\n  return socket;\n};\n\n/**\n * Get the port number from the host. Or guess it based on the connection type.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {String} The port number.\n *\n * @api private\n */\ncommon.getPort = function (req) {\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\n  return res ? res[1] : common.hasEncryptedConnection(req) ? '443' : '80';\n};\n\n/**\n * Check if the request has an encrypted connection.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {Boolean} Whether the connection is encrypted or not.\n *\n * @api private\n */\ncommon.hasEncryptedConnection = function (req) {\n  return Boolean(req.connection.encrypted || req.connection.pair);\n};\n\n/**\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\n *\n * @return {String} The generated path.\n *\n * @api private\n */\n\ncommon.urlJoin = function () {\n  //\n  // We do not want to mess with the query string. All we want to touch is the path.\n  //\n  var args = Array.prototype.slice.call(arguments),\n    lastIndex = args.length - 1,\n    last = args[lastIndex],\n    lastSegs = last.split('?'),\n    retSegs;\n  args[lastIndex] = lastSegs.shift();\n\n  //\n  // Join all strings, but remove empty strings so we don't get extra slashes from\n  // joining e.g. ['', 'am']\n  //\n  retSegs = [args.filter(Boolean).join('/').replace(/\\/+/g, '/').replace(/:\\//g, '://')];\n\n  // Only join the query string if it exists so we don't have trailing a '?'\n  // on every request\n\n  // Handle case where there could be multiple ? in the URL.\n  retSegs.push.apply(retSegs, lastSegs);\n  return retSegs.join('?');\n};\n\n/**\n * Check the host and see if it potentially has a port in it (keep it simple)\n *\n * @returns {Boolean} Whether we have one or not\n *\n * @api private\n */\nfunction hasPort(host) {\n  return !!~host.indexOf(':');\n}\n;","map":{"version":3,"names":["common","exports","url","require","extend","_extend","required","upgradeHeader","isSSL","setupOutgoing","outgoing","options","req","forward","port","test","protocol","forEach","e","method","headers","auth","rejectUnauthorized","secure","agent","localAddress","connection","target","targetPath","prependPath","path","outgoingPath","toProxy","parse","ignorePath","urlJoin","changeOrigin","host","hasPort","setupSocket","socket","setTimeout","setNoDelay","setKeepAlive","getPort","res","match","hasEncryptedConnection","Boolean","encrypted","pair","args","Array","prototype","slice","call","arguments","lastIndex","length","last","lastSegs","split","retSegs","shift","filter","join","replace","push","apply","indexOf"],"sources":["/home/bsquiat/Development/code/Phase2/music-app-project/node_modules/cors-anywhere/node_modules/http-proxy/lib/http-proxy/common.js"],"sourcesContent":["var common   = exports,\n    url      = require('url'),\n    extend   = require('util')._extend,\n    required = require('requires-port');\n\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\n    isSSL = /^https|wss/;\n\n/**\n * Simple Regex for testing if protocol is https\n */\ncommon.isSSL = isSSL;\n/**\n * Copies the right headers from `options` and `req` to\n * `outgoing` which is then used to fire the proxied\n * request.\n *\n * Examples:\n *\n *    common.setupOutgoing(outgoing, options, req)\n *    // => { host: ..., hostname: ...}\n *\n * @param {Object} Outgoing Base object to be filled with required properties\n * @param {Object} Options Config object passed to the proxy\n * @param {ClientRequest} Req Request Object\n * @param {String} Forward String to select forward or target\n * \n * @return {Object} Outgoing Object with all required properties set\n *\n * @api private\n */\n\ncommon.setupOutgoing = function(outgoing, options, req, forward) {\n  outgoing.port = options[forward || 'target'].port ||\n                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\n\n  ['host', 'hostname', 'socketPath', 'pfx', 'key',\n    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(\n    function(e) { outgoing[e] = options[forward || 'target'][e]; }\n  );\n\n  outgoing.method = req.method;\n  outgoing.headers = extend({}, req.headers);\n\n  if (options.headers){\n    extend(outgoing.headers, options.headers);\n  }\n\n  if (options.auth) {\n    outgoing.auth = options.auth;\n  }\n\n  if (isSSL.test(options[forward || 'target'].protocol)) {\n    outgoing.rejectUnauthorized = (typeof options.secure === \"undefined\") ? true : options.secure;\n  }\n\n\n  outgoing.agent = options.agent || false;\n  outgoing.localAddress = options.localAddress;\n\n  //\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\n  // as node core doesn't handle this COMPLETELY properly yet.\n  //\n  if (!outgoing.agent) {\n    outgoing.headers = outgoing.headers || {};\n    if (typeof outgoing.headers.connection !== 'string'\n        || !upgradeHeader.test(outgoing.headers.connection)\n       ) { outgoing.headers.connection = 'close'; }\n  }\n\n\n  // the final path is target path + relative path requested by user:\n  var target = options[forward || 'target'];\n  var targetPath = target && options.prependPath !== false\n    ? (target.path || '')\n    : '';\n\n  //\n  // Remark: Can we somehow not use url.parse as a perf optimization?\n  //\n  var outgoingPath = !options.toProxy\n    ? (url.parse(req.url).path || '/')\n    : req.url;\n\n  //\n  // Remark: ignorePath will just straight up ignore whatever the request's\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\n  // you are doing and are using conflicting options.\n  //\n  outgoingPath = !options.ignorePath ? outgoingPath : '/';\n\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\n\n  if (options.changeOrigin) {\n    outgoing.headers.host =\n      required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host)\n        ? outgoing.host + ':' + outgoing.port\n        : outgoing.host;\n  }\n  return outgoing;\n};\n\n/**\n * Set the proper configuration for sockets,\n * set no delay and set keep alive, also set\n * the timeout to 0.\n *\n * Examples:\n *\n *    common.setupSocket(socket)\n *    // => Socket\n *\n * @param {Socket} Socket instance to setup\n * \n * @return {Socket} Return the configured socket.\n *\n * @api private\n */\n\ncommon.setupSocket = function(socket) {\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n\n  socket.setKeepAlive(true, 0);\n\n  return socket;\n};\n\n/**\n * Get the port number from the host. Or guess it based on the connection type.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {String} The port number.\n *\n * @api private\n */\ncommon.getPort = function(req) {\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\n\n  return res ?\n    res[1] :\n    common.hasEncryptedConnection(req) ? '443' : '80';\n};\n\n/**\n * Check if the request has an encrypted connection.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {Boolean} Whether the connection is encrypted or not.\n *\n * @api private\n */\ncommon.hasEncryptedConnection = function(req) {\n  return Boolean(req.connection.encrypted || req.connection.pair);\n};\n\n/**\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\n *\n * @return {String} The generated path.\n *\n * @api private\n */\n\ncommon.urlJoin = function() {\n    //\n    // We do not want to mess with the query string. All we want to touch is the path.\n    //\n  var args = Array.prototype.slice.call(arguments),\n      lastIndex = args.length - 1,\n      last = args[lastIndex],\n      lastSegs = last.split('?'),\n      retSegs;\n\n  args[lastIndex] = lastSegs.shift();\n\n  //\n  // Join all strings, but remove empty strings so we don't get extra slashes from\n  // joining e.g. ['', 'am']\n  //\n  retSegs = [\n    args.filter(Boolean).join('/').replace(/\\/+/g, '/').replace(/:\\//g, '://')\n  ];\n\n  // Only join the query string if it exists so we don't have trailing a '?'\n  // on every request\n\n  // Handle case where there could be multiple ? in the URL.\n  retSegs.push.apply(retSegs, lastSegs);\n\n  return retSegs.join('?')\n};\n\n/**\n * Check the host and see if it potentially has a port in it (keep it simple)\n *\n * @returns {Boolean} Whether we have one or not\n *\n * @api private\n */\nfunction hasPort(host) {\n  return !!~host.indexOf(':');\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}