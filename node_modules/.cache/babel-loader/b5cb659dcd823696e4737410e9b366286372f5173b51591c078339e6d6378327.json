{"ast":null,"code":"var http = require('http'),\n  https = require('https'),\n  common = require('../common'),\n  passes = exports;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\nvar passes = exports;\n[\n/**\n * WebSocket requests must have the `GET` method and\n * the `upgrade:websocket` header\n *\n * @param {ClientRequest} Req Request object\n * @param {Socket} Websocket\n *\n * @api private\n */\n\nfunction checkMethodAndHeader(req, socket) {\n  if (req.method !== 'GET' || !req.headers.upgrade) {\n    socket.destroy();\n    return true;\n  }\n  if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n    socket.destroy();\n    return true;\n  }\n},\n/**\n * Sets `x-forwarded-*` headers if specified in config.\n *\n * @param {ClientRequest} Req Request object\n * @param {Socket} Websocket\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\n\nfunction XHeaders(req, socket, options) {\n  if (!options.xfwd) return;\n  var values = {\n    for: req.connection.remoteAddress || req.socket.remoteAddress,\n    port: common.getPort(req),\n    proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n  };\n  ['for', 'port', 'proto'].forEach(function (header) {\n    req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n  });\n},\n/**\n * Does the actual proxying. Make the request and upgrade it\n * send the Switching Protocols request and pipe the sockets.\n *\n * @param {ClientRequest} Req Request object\n * @param {Socket} Websocket\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction stream(req, socket, options, head, server, clb) {\n  common.setupSocket(socket);\n  if (head && head.length) socket.unshift(head);\n  var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req));\n  // Error Handler\n  proxyReq.on('error', onOutgoingError);\n  proxyReq.on('response', function (res) {\n    // if upgrade event isn't going to happen, close the socket\n    if (!res.upgrade) socket.end();\n  });\n  proxyReq.on('upgrade', function (proxyRes, proxySocket, proxyHead) {\n    proxySocket.on('error', onOutgoingError);\n\n    // Allow us to listen when the websocket has completed\n    proxySocket.on('end', function () {\n      server.emit('close', proxyRes, proxySocket, proxyHead);\n    });\n\n    // The pipe below will end proxySocket if socket closes cleanly, but not\n    // if it errors (eg, vanishes from the net and starts returning\n    // EHOSTUNREACH). We need to do that explicitly.\n    socket.on('error', function () {\n      proxySocket.end();\n    });\n    common.setupSocket(proxySocket);\n    if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n    socket.write('HTTP/1.1 101 Switching Protocols\\r\\n');\n    socket.write(Object.keys(proxyRes.headers).map(function (i) {\n      return i + \": \" + proxyRes.headers[i];\n    }).join('\\r\\n') + '\\r\\n\\r\\n');\n    proxySocket.pipe(socket).pipe(proxySocket);\n    server.emit('open', proxySocket);\n    server.emit('proxySocket', proxySocket); //DEPRECATED.\n  });\n\n  return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n  function onOutgoingError(err) {\n    if (clb) {\n      clb(err, req, socket);\n    } else {\n      server.emit('error', err, req, socket);\n    }\n    socket.end();\n  }\n}] // <--\n.forEach(function (func) {\n  passes[func.name] = func;\n});","map":{"version":3,"names":["http","require","https","common","passes","exports","checkMethodAndHeader","req","socket","method","headers","upgrade","destroy","toLowerCase","XHeaders","options","xfwd","values","for","connection","remoteAddress","port","getPort","proto","hasEncryptedConnection","forEach","header","stream","head","server","clb","setupSocket","length","unshift","proxyReq","isSSL","test","target","protocol","request","setupOutgoing","ssl","on","onOutgoingError","res","end","proxyRes","proxySocket","proxyHead","emit","write","Object","keys","map","i","join","pipe","err","func","name"],"sources":["/home/bsquiat/Development/code/Phase2/music-app-project/node_modules/cors-anywhere/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js"],"sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    common = require('../common'),\n    passes = exports;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\nvar passes = exports;\n\n[\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  function checkMethodAndHeader (req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function XHeaders(req, socket, options) {\n    if(!options.xfwd) return;\n\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  function stream(req, socket, options, head, server, clb) {\n    common.setupSocket(socket);\n\n    if (head && head.length) socket.unshift(head);\n\n\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) socket.end();\n    });\n\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n\n      common.setupSocket(proxySocket);\n\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      socket.write('HTTP/1.1 101 Switching Protocols\\r\\n');\n      socket.write(Object.keys(proxyRes.headers).map(function(i) {\n        return i + \": \" + proxyRes.headers[i];\n      }).join('\\r\\n') + '\\r\\n\\r\\n');\n      proxySocket.pipe(socket).pipe(proxySocket);\n\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}